---
title: 2018华为软件精英挑战赛总结
date: 2018-04-29 15:13:40
tags: [c++,华为软挑]
categories: 随笔

---

**队名：胜利属于兄弟会
ShaLian
2018/4/28**

做了将近一个半月的华为软件精英挑战赛最终落下了帷幕，在整个比赛中我们收获了很多，有算法软件知识，也有团队交流合作能力。最终取得**杭厦赛区13名**的成绩，对没能取得前4还是有点遗憾的，但是因为结束了一个多月的紧张备战还是感到轻松了很多。

#### **比赛结果**

初赛
![](http://ols4zt49w.bkt.clouddn.com/1524987094%281%29.png)
复赛
![](http://ols4zt49w.bkt.clouddn.com/1524987119%281%29.png)

#### **比赛赛题**

**题目背景**
云平台为了满足不同租户的需求，提供了一种可随时自助获取、可弹性伸缩的云服务器，即弹性云服务器（Elastic Cloud Server，ECS）。为容纳更多的租户请求、并尽可能提高资源利用率、降低成本，自动化、智能化的资源调度管理系统非常关键。

由于租户对ECS实例（虚拟机，VM）请求的行为具有一定规律，可以通过对历史ECS实例请求的分析，预测到未来一段时间的ECS实例请求，然后对预测的请求分配资源（如图1所示），这样可以找到一个接近最优的分配策略，实现资源最大化利用，同时也能参考预测的结果制定云数据中心的建设计划。
![](http://ols4zt49w.bkt.clouddn.com/1524988789%281%29.png)
赛题更加详细的信息请参考2018华为软件精英挑战赛官网 http://codecraft.devcloud.huaweicloud.com/home/detail

比赛赛题主要可以分成两个步骤：
1、根据历史虚拟机请求数量预测接下来几天的各类虚拟机请求数量（主要通过机器学习方法）。
2、将预测出来的虚拟机放置进规定规格的物理服务器中，使得物理服务器的资源（CPU或者内存）利用率最高。

#### **比赛体验**
比赛刚开始时，我和舍友看到华为官方推送了相关比赛信息，于是就想试试，毕竟之前还没参加过类似纯算法的比赛（虽然后期觉得算法，代码能力，运气各占5：4：1）。正好之前另一个同学也提过这个比赛，于是我两便叫上他一起组队了。

首先便是分工问题，由于是团队赛，分工好坏其实对团队的效率和成绩起到关键作用，幸运的是我们分工还是比较好的，一个人负责文件的读取和数据的去噪，一个人负责训练数据并预测模型部分，还有一个人负责最后的放置问题。在比赛过程中我们每天吃饭的时候都会一起交流，相互交流自己的ideal，我觉得这是一个团队所必需的，因为有时可能别人能发现你没有考虑到的问题，同时在交流中也能互相学到东西。

在比赛中我感受到了平时的知识长时间不用是会遗忘的，虽然之前接触过c++的STL，但是由于平时用c用的比较多，比赛时大部分都遗忘了，虽然官方也支持用c实现，但是在实际撸码中发现STL能为我们提供很多方便。

第二，在比赛中我也感受到了竞争的激烈，可能今天你还在榜上前四，过了一晚你就掉出前十了，毕竟喜欢熬夜的大佬还是很多的，这也激励着我们进一步的改善优化，毕竟不到最后一刻结局还是个未解之谜。

#### **比赛收获**
在比赛中我主要负责数据的训练和预测模型的建立，预测模型很多，但是每种不一定都适合时间序列预测。

```
1、多元线性回归模型
线性回归可谓是世界上最知名的建模方法之一，也是我们第一个接触的模型。线性回归用最适直线(回归线)去建立因变量Y和一个或多个自变量X之间的关系。可以用公式来表示：
   Y=a+b*X+e
   a为截距，b为回归线的斜率，e是误差项。
   简单线性回归与多元线性回归的差别在于：多元线性回归有多个(>1)自变量，而简单线性回归只有一个自变量。到现在我们的问题就是：如何找到那条回归线？
   
我们可以通过最小二乘法把这个问题解决。其实最小二乘法就是线性回归模型的损失函数，只有把损失函数做到最小时得出的参数，才是我们最需要的参数。损失函数我们可以采用差方和。

重点：
1.自变量与因变量之间必须要有线性关系。
2.多重共线性、自相关和异方差对多元线性回归的影响很大。
3.线性回归对异常值非常敏感，其能严重影响回归线，最终影响预测值。（因此在训练数据前需要做好去噪，我们采用过平均滤波，高斯滤波等，最终采用的是高斯滤波）

调试过程中遇到的问题并做的小结：
多元回归：
1、循环预测N次，将N天数据累加。(后来事实证明不能将最先预测的数据带入，重新训练生成新的参数，从而生成新的预测数据。)
2、动态申请二维数组，将每天的数据赋值给它。（原先定义的时候是长度固定的数组，可以存放100天的数据，但是实际上可能没有这么多的天数，所以后面没数据的天数数据会全部为初始值0，影响训练效果。）
3、N天和作为输入，训练预测N天的和。（后来效果没有一天一天预测的效果好）
4、降噪完在存入数据。
```
关于其他回归模型，有兴趣的可以参考一些博文：
https://blog.csdn.net/zc02051126/article/details/54709096
https://www.jianshu.com/p/15dd20f8d02c


```
2、指数平滑预测
我们初赛用的是二次的，复赛用的是三次的。
一次指数平滑实际就是对历史数据的加权平均，它可以用于任何一种没有明显函数规律，但确实存在某种前后关联的时间序列的短期预测。
局限性：
第一，预测值不能反映趋势变动、季节波动等有规律的变动；
第二，这种方法多适用于短期预测，而不适合作中长期的预测；
第三，由于预测值是历史数据的均值，因此与实际序列的变化相比有滞后现象。

二次指数
二次指数平滑是对一次指数平滑的再平滑。它适用于具有线性趋势的时间数列。（一次指数平滑没有考虑历史数据变化趋势对当前预测值的影响， 因此无法预测趋势）

三次指数
1. 与前两种相比，我们多考虑一个因素：季节性效应（ Seasonality）。这种平均模型考虑的季节性效应，在股票或者期货价格中都会比较常见，比如  在过年前A股市场通常会交易比较频繁，在小麦成熟的时候   小麦期货价格   也会有比较明显的波动。

在尝试此模型的过程中，平滑系数a的选取至关重要，我们后来尝试了用暴力解法来确定a，但是如果将a从0-1之间每0.001累加从而暴力求解的话会发现有时会超时，因此我后来在0-1之间截取不同段从而确定最佳的平滑系数在那个区间，从而减少暴力求解的时间。同时，对于不同的去噪方式，对平滑系数的选取都会有一定的影响。

注意：
1、指数平滑预测只适合中短期的时间序列预测，预测时间过长或预测起始时间和训练数据结束时间间隔太久时，会影响它的准确度。
2、复赛时，由于预测起始时间和所给训练数据间存在间隔T,为了避免误差过大，可采用累加N天数据的和做为训练数据。
   主要分两步：N1=T，预测出紧挨着训练数据的 T天的数据和data1; N2=T+预测天数，预测出紧挨着训练数据的 T+预测天数 天的数据和data2；最后data2-data1即为预测天数的数据和。
```
对于指数平滑预测模型感兴趣的还可以参考以下博文：
https://www.cnblogs.com/TTyb/p/5716125.html
https://www.cnblogs.com/devilmaycry812839668/p/6935167.html

至于其他模型，我们还试过最佳拟合直线（和简单线性回归类似）；bp神经网络；adaboost(二分类模型)等。在此处就不再一一展开了，有兴趣的可以自己查阅相关资料。
[最佳拟合直线](https://blog.csdn.net/Pruett/article/details/68951232)
[Adaboost算法原理分析和实例](https://blog.csdn.net/guyuealian/article/details/70995333)

附：在和大佬的交流中，我发现杭电大部人人都用的ARIMA模型（自回归移动平均），但是由于时间原因我并没有仔细研究，有兴趣的人可以试试。

最后，附上个人观点，其实每种模型都有各自的优缺点，不管你尝试哪种模型，只要你想办法去优化模型，针对具体数据去改善模型都能取得不错的成绩。

```
3、装箱问题
这部分主要是由队友做的，我们一开始采用的是最简单的方法（也是官方文档示例方法）是贪心+首次适应法（FF算法），即将所有的虚拟机按次序放入物理服务器中，对于每个虚拟机，检查服务器资源是否足够放下该虚拟机，如果可以放下就将其放在这台服务器上，如果服务器剩余资源不足以放下该虚拟机，则新建一台服务器，将虚拟机放入新建的服务器……直到最后放置完所有的虚拟机，将每个服务器放置的虚拟机输出即可。
显然，首次适应方法有个弊端，可能会造成每个服务器都有挺多资源剩余，但是却无法被后来的虚拟机利用。由于在采用首次适应法的前提下，虚拟机放置方式只与虚拟机初始排列顺序有关，所以我们可以用智能算法对初始排列顺序进行优化，求得接近最优解的解。

后来我们采用模拟退火算法进行最优解的寻找，模拟退火算法（Simulated Annealing Algorithm）用于优化问题的出发点是基于物理中固体物质的退火过程与一般优化问题的相似性，虽然模拟退火法能够提高利用率，但是有时评估次数设置的过多可能会导致程序超时（60s），而且到后期发现退火的利用率也到极限了（cpu和内存比值）。

后来和其他队的交流，想要尽快放满一台服务器，可以尝试动态规划（DP）和最佳适应法。最终我们写了六种放置方法，并在调用前判断哪种的利用率高，然后调用哪种。（哈哈哈，也是厉害了，居然想到了这种方法。。。）
```
作为第一次参加类似的比赛（纯算法），我还是感触颇深的，也认识到了自己和大佬间的差距，希望以后有机会再一较高下吧。
